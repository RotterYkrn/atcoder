{
	"UnionFind-D1": {
		"prefix": "uni1",
		"body": [
			"struct UnionFind {",
			"\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2",
			"\tvector<int> rank;",
			"\tint group;",
			"\t",
			"\texplicit UnionFind(const int N) : par(N), rank(N), group(N) { //最初は全てが根であるとして初期化",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tpar[i] = i;",
			"\t\t\trank[i] = 0;",
			"\t\t}",
			"\t}",
			"\t",
			"\tint root(const int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}",
			"\t\tif (par[x] == x) return x;",
			"\t\treturn par[x] = root(par[x]);",
			"\t}",
			"\t",
			"\tvoid unite(const int x, const int y) { // xとyの木を併合",
			"\t\tint rx = root(x); //xの根をrx",
			"\t\tint ry = root(y); //yの根をry",
			"\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"\t\t",
			"\t\tif (rank[rx] < rank[ry]){",
			"\t\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける",
			"\t\t} else {",
			"\t\t\tpar[ry] = rx;",
			"\t\t\tif (rank[rx] == rank[ry]) rank[rx]++;",
			"\t\t}",
			"\t\tgroup--;",
			"\t}",
			"\t",
			"\tbool same(const int x, const int y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"};"
		],
		"description": "1次元のUnionFind"
	},
	"UnionFind-D2": {
		"prefix": "uni2",
		"body": [
			"struct UnionFind {",
			"\tvector<vector<pair<int, int>>> par; // par[i][j]:(i,j)の親の番号　(例) par[3][4] = {2,5} : (3,4)の親が(2,5)",
			"\tvector<vector<int>> rank;",
			"\tint group;",
			"\t",
			"\texplicit UnionFind(const int N, const int M) : par(N, vector<pair<int, int>>(M)), rank(N, vector<int>(M)), group(N * M) { //最初は全てが根であるとして初期化",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor (int j = 0; j < M; j++) {",
			"\t\t\t\tpar[i][j] = {i, j};",
			"\t\t\t\trank[i][j] = 0;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tpair<int, int> root(const pair<int, int> x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}",
			"\t\tif (par[x.first][x.second] == x) return x;",
			"\t\treturn par[x.first][x.second] = root(par[x.first][x.second]);",
			"\t}",
			"\t",
			"\tvoid unite(const pair<int, int> x, const pair<int, int> y) { // xとyの木を併合",
			"\t\tpair<int, int> rx = root(x); //xの根をrx",
			"\t\tpair<int, int> ry = root(y); //yの根をry",
			"\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"\t\t",
			"\t\tif (rank[rx.first][rx.second] < rank[ry.first][ry.second]){",
			"\t\t\tpar[rx.first][rx.second] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける",
			"\t\t} else {",
			"\t\t\tpar[ry.first][ry.second] = rx;",
			"\t\t\tif (rank[rx.first][rx.second] == rank[ry.first][ry.second]) rank[rx.first][rx.second]++;",
			"\t\t}",
			"\t\tgroup--;",
			"\t}",
			"\t",
			"\tbool same(const pair<int, int> x, const pair<int, int> y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"};"
		],
		"description": "2次元のUnionFind"
	},
	"Combination": {
		"prefix": "com",
		"body": [
			"struct Combination {",
			"\tvector<long long> fac, finv;",
			"\tconst int MOD = modint${1|1000000007,998244353|}::mod();",
			"\t",
			"\texplicit Combination(int N) : fac(N), finv(N) {",
			"\t\tvector<long long> inv(N);",
			"\t\tfac[0] = fac[1] = 1;",
			"\t\tfinv[0] = finv[1] = 1;",
			"\t\tinv[1] = 1;",
			"\t\tfor (int i = 2; i < N; i++){",
			"\t\t\tfac[i] = fac[i - 1] * i % MOD;",
			"\t\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
			"\t\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;",
			"\t\t}",
			"\t}",
			"\t",
			"\tinline long long calc(const int n, const int k) const noexcept {",
			"\t\tif (n < k) return 0;",
			"\t\tif (n < 0 || k < 0) return 0;",
			"\t\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
			"\t}",
			"};"
		],
		"description": "逆元を使用したnCkの計算"
	},
	"SegmentTree": {
		"prefix": "seg",
		"body": [
			"template<class T, const T& (* const op)(const T &, const T &) = max, const T e = T()>",
			"struct SegTree {",
			"\tvector<T> tree, lazy;",
			"\tsize_t n;",
			"\tconst T LAZY_DEF = numeric_limits<T>::max();",
			"\t",
			"\texplicit SegTree(const size_t N) noexcept {",
			"\t\tsize_t tree_size = 2;",
			"\t\twhile (tree_size < N) {",
			"\t\t\ttree_size *= 2;",
			"\t\t}",
			"\t\ttree = vector<T>(tree_size * 2, e);",
			"\t\tlazy = vector<T>(tree_size * 2, LAZY_DEF);",
			"\t\tn = tree_size;",
			"\t}",
			"\t",
			"\texplicit SegTree(const vector<T> v) noexcept : SegTree(v.size()) {",
			"\t\tcopy(v.begin(), v.end(), tree.begin() + n - 1);",
			"\t\tfor (size_t i = n - 2; i >= 0; i--) {",
			"\t\t\ttree[i] = op(tree[i * 2 + 1], tree[i * 2 + 2]);",
			"\t\t}",
			"\t}",
			"\t",
			"\tinline void delayed_evaluation(size_t node) noexcept {",
			"\t\tif (lazy[node] == LAZY_DEF) {",
			"\t\t\treturn;",
			"\t\t}",
			"\t\tif (node < n - 1) {",
			"\t\t\tlazy[node * 2 + 1] = lazy[node];",
			"\t\t\tlazy[node * 2 + 2] = lazy[node];",
			"\t\t}",
			"\t\ttree[node] = lazy[node];",
			"\t\tlazy[node] = LAZY_DEF;",
			"\t}",
			"\t",
			"\tvoid set(const size_t sl, const size_t sr, const T v, const size_t node, const size_t nl, const size_t nr) noexcept {",
			"\t\tdelayed_evaluation(node);",
			"\t\tif (sl <= nl && nr <= sr) {",
			"\t\t\tlazy[node] = v;",
			"\t\t\tdelayed_evaluation(node);",
			"\t\t} else if (sl < nr && nl < sr) {",
			"\t\t\tset(sl, sr, v, node * 2 + 1, nl, (nl + nr) / 2);",
			"\t\t\tset(sl, sr, v, node * 2 + 2, (nl + nr) / 2, nr);",
			"\t\t\ttree[node] = op(tree[node * 2 + 1], tree[node * 2 + 2]);",
			"\t\t}",
			"\t}",
			"\tinline void set(const size_t l, const size_t r, const T value) noexcept {",
			"\t\tset(l, r, value, 0, 0, n);",
			"\t}",
			"\tinline void set(const size_t p, const T value) noexcept {",
			"\t\tset(p, p + 1, value);",
			"\t}",
			"\t",
			"\tT query_sub(const size_t ql, const size_t qr, const size_t node, const size_t nl, const size_t nr) noexcept {",
			"\t\tdelayed_evaluation(node);",
			"\t\tif (nr <= ql || qr <= nl) {",
			"\t\t\treturn e;",
			"\t\t} else if (ql <= nl && nr <= qr) {",
			"\t\t\treturn tree[node];",
			"\t\t} else {",
			"\t\t\tT vl = query_sub(ql, qr, node * 2 + 1, nl, (nl + nr) / 2);",
			"\t\t\tT vr = query_sub(ql, qr, node * 2 + 2, (nl + nr) / 2, nr);",
			"\t\t\treturn op(vl, vr);",
			"\t\t}",
			"\t}",
			"\t// [l, r)",
			"\tinline T query(const size_t l, const size_t r) noexcept {",
			"\t\treturn query_sub(l, r, 0, 0, n);",
			"\t}",
			"\t",
			"\tinline T query_all() noexcept {",
			"\t\treturn tree[0];",
			"\t}",
			"};"
		],
		"description": "セグメント木（遅延評価付き）"
	},
	"CumulativeSumArray-D1": {
		"prefix": "cs1",
		"body": [
			"template<class T>",
			"struct CumulativeSumArray1 {",
			"\tvector<T> arr;",
			"\t",
			"\texplicit CumulativeSumArray1(const auto &origin) : arr(origin.size() + 1, static_cast<T>(0)) {",
			"\t\tfor (size_t i = 0; i < origin.size(); i++) {",
			"\t\t\tarr[i + 1] = origin[i] + arr[i];",
			"\t\t}",
			"\t}",
			"\t",
			"\tT query(const int l, const int r) const noexcept {",
			"\t\treturn arr[r] - arr[l];",
			"\t}",
			"};"
		],
		"description": "1次元の累積和"
	},
	"CumulativeSumArray-D2": {
		"prefix": "cs2",
		"body": [
			"template<class T>",
			"struct CumulativeSumArray2 {",
			"\tvector<vector<T>> arr;",
			"\t",
			"\texplicit CumulativeSumArray2(const auto &origin) : arr(origin.size() + 1,",
			"\t\t\t\t\t\t\t\t\t\t\t\t\t\t   vector(origin[0].size() + 1, static_cast<T>(0))) {",
			"\t\tfor (size_t i = 0; i < origin.size(); i++) {",
			"\t\t\tfor (size_t j = 0; j < origin[0].size(); j++) {",
			"\t\t\t\tarr[i + 1][j + 1] = origin[i][j];",
			"\t\t\t\tarr[i + 1][j + 1] += arr[i][j + 1] + arr[i + 1][j];",
			"\t\t\t\tarr[i + 1][j + 1] -= arr[i][j];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tT query(const int (&l)[2], const int (&r)[2]) const noexcept {",
			"\t\tT ans = 0;",
			"\t\tans = arr[r[0]][r[1]];",
			"\t\tans -= arr[l[0]][r[1]] + arr[r[0]][l[1]];",
			"\t\tans += arr[l[0]][l[1]];",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "2次元の累積和"
	},
	"CumulativeSumArray-D3": {
		"prefix": "cs3",
		"body": [
			"template<class T>",
			"struct CumulativeSumArray3 {",
			"\tvector<vector<vector<T>>> arr;",
			"\t",
			"\texplicit CumulativeSumArray3(const auto &origin) : arr(origin.size() + 1,",
			"\t\t\t\t\t\t\t\t\t\t\t\t\t\t   vector(origin[0].size() + 1,",
			"\t\t\t\t\t\t\t\t\t\t\t\t\t\t   vector(origin[0][0].size() + 1, static_cast<T>(0)))) {",
			"\t\tfor (size_t i = 0; i < origin.size(); i++) {",
			"\t\t\tfor (size_t j = 0; j < origin[0].size(); j++) {",
			"\t\t\t\tfor (size_t k = 0; k < origin[0][0].size(); k++) {",
			"\t\t\t\t\tarr[i + 1][j + 1][k + 1] = origin[i][j][k];",
			"\t\t\t\t\t",
			"\t\t\t\t\tarr[i + 1][j + 1][k + 1] += arr[i][j + 1][k + 1]",
			"\t\t\t\t\t\t\t\t\t\t\t  + arr[i + 1][j][k + 1]",
			"\t\t\t\t\t\t\t\t\t\t\t  + arr[i + 1][j + 1][k];",
			"\t\t\t\t\t",
			"\t\t\t\t\tsa[i + 1][j + 1][k + 1] -= arr[i][j][k + 1]",
			"\t\t\t\t\t\t\t\t\t\t\t  + arr[i + 1][j][k]",
			"\t\t\t\t\t\t\t\t\t\t\t  + arr[i][j + 1][k];",
			"\t\t\t\t\t",
			"\t\t\t\t\tarr[i + 1][j + 1][k + 1] += arr[i][j][k];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tT query(const int (&l)[3], const int (&r)[3]) const noexcept {",
			"\t\tT ans = 0;",
			"\t\tans = arr[r[0]][r[1]][r[2]];",
			"\t\tans -= arr[l[0]][r[1]][r[2]] + arr[r[0]][l[1]][r[2]] + arr[r[0]][r[1]][l[2]];",
			"\t\tans += arr[l[0]][l[1]][r[2]] + arr[r[0]][l[1]][l[2]] + arr[l[0]][r[1]][l[2]];",
			"\t\tans -= arr[l[0]][l[1]][l[2]];",
			"\t\treturn ans;",
			"\t}",
			"};"
		],
		"description": "3次元の累積和"
	}
}