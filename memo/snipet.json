{
	"UnionFind-D1": {
		"prefix": "uni1",
		"body": [
			"struct UnionFind {",
			"\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2",
			"\tvector<int> rank;",
			"\tint group;",
			"\t",
			"\tUnionFind(const int N) : par(N), rank(N), group(N) { //最初は全てが根であるとして初期化",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tpar[i] = i;",
			"\t\t\trank[i] = 0;",
			"\t\t}",
			"\t}",
			"\t",
			"\tint root(const int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}",
			"\t\tif (par[x] == x) return x;",
			"\t\treturn par[x] = root(par[x]);",
			"\t}",
			"\t",
			"\tvoid unite(const int x, const int y) { // xとyの木を併合",
			"\t\tint rx = root(x); //xの根をrx",
			"\t\tint ry = root(y); //yの根をry",
			"\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"\t\t",
			"\t\tif (rank[rx] < rank[ry]){",
			"\t\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける",
			"\t\t} else {",
			"\t\t\tpar[ry] = rx;",
			"\t\t\tif (rank[rx] == rank[ry]) rank[rx]++;",
			"\t\t}",
			"\t\tgroup--;",
			"\t}",
			"\t",
			"\tbool same(const int x, const int y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"};"
		],
		"description": "1次元のUnionFind"
	},
	"UnionFind-D2": {
		"prefix": "uni2",
		"body": [
			"struct UnionFind {",
			"\tvector<vector<pair<int, int>>> par; // par[i][j]:(i,j)の親の番号　(例) par[3][4] = {2,5} : (3,4)の親が(2,5)",
			"\tvector<vector<int>> rank;",
			"\tint group;",
			"\t",
			"\tUnionFind(const int N, const int M) : par(N, vector<pair<int, int>>(M)), rank(N, vector<int>(M)), group(N * M) { //最初は全てが根であるとして初期化",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor (int j = 0; j < M; j++) {",
			"\t\t\t\tpar[i][j] = {i, j};",
			"\t\t\t\trank[i][j] = 0;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t",
			"\tpii root(const pair<int, int> x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}",
			"\t\tif (par[x.first][x.second] == x) return x;",
			"\t\treturn par[x.first][x.second] = root(par[x.first][x.second]);",
			"\t}",
			"\t",
			"\tvoid unite(const pair<int, int> x, const pair<int, int> y) { // xとyの木を併合",
			"\t\tpair<int, int> rx = root(x); //xの根をrx",
			"\t\tpair<int, int> ry = root(y); //yの根をry",
			"\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま",
			"\t\t",
			"\t\tif (rank[rx.first][rx.second] < rank[ry.first][ry.second]){",
			"\t\t\tpar[rx.first][rx.second] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける",
			"\t\t} else {",
			"\t\t\tpar[ry.first][ry.second] = rx;",
			"\t\t\tif (rank[rx.first][rx.second] == rank[ry.first][ry.second]) rank[rx.first][rx.second]++;",
			"\t\t}",
			"\t\tgroup--;",
			"\t}",
			"\t",
			"\tbool same(const pair<int, int> x, const pair<int, int> y) { // 2つのデータx, yが属する木が同じならtrueを返す",
			"\t\treturn root(x) == root(y);",
			"\t}",
			"};"
		],
		"description": "2次元のUnionFind"
	}
}